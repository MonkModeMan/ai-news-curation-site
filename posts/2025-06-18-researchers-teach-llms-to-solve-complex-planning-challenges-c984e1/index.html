<!DOCTYPE html><html lang="ja"> <head><meta charset="UTF-8"><title>Researchers teach LLMs to solve complex planning challenges</title><meta name="viewport" content="width=device-width, initial-scale=1.0"><link rel="stylesheet" href="/ai-news-curation-site/_astro/_page_.CO8YC2Z5.css"></head> <body class="bg-gray-100 text-gray-800 font-sans px-4 py-6"> <div class="max-w-3xl mx-auto"> <!-- ‚úÖ „Çø„Ç§„Éà„É´ --> <header class="mb-6"> <h1 class="text-3xl font-extrabold text-sky-500 mb-2">üì∞ Researchers teach LLMs to solve complex planning challenges</h1> <p class="text-sm text-gray-500"> 2025/4/2 ‚Äì MIT  <a href="https://news.mit.edu/2025/researchers-teach-llms-to-solve-complex-planning-challenges-0402" target="_blank" rel="noopener noreferrer" class="text-sky-500 hover:text-gray-500 no-underline border-b border-transparent hover:border-gray-300 transition">
ÂÖÉË®ò‰∫ã
</a>  </p> </header> <!-- ‚úÖ Êú¨Êñá --> <article class="prose prose-sm sm:prose lg:prose-lg max-w-none bg-white rounded-lg shadow p-6"> Audio
Imagine a coffee company trying to optimize its supply chain. The company sources beans from three suppliers, roasts them at two facilities into either dark or light coffee, and then ships the roasted coffee to three retail locations. The suppliers have different fixed capacity, and roasting costs and shipping costs vary from place to place.
The company seeks to minimize costs while meeting a 23 percent increase in demand.
Wouldn‚Äôt it be easier for the company to just ask ChatGPT to come up with an optimal plan? In fact, for all their incredible capabilities, large language models (LLMs) often perform poorly when tasked with directly solving such complicated planning problems on their own.
Rather than trying to change the model to make an LLM a better planner, MIT researchers took a different approach. They introduced a framework that guides an LLM to break down the problem like a human would, and then automatically solve it using a powerful software tool.
A user only needs to describe the problem in natural language ‚Äî no task-specific examples are needed to train or prompt the LLM. The model encodes a user‚Äôs text prompt into a format that can be unraveled by an optimization solver designed to efficiently crack extremely tough planning challenges.
During the formulation process, the LLM checks its work at multiple intermediate steps to make sure the plan is described correctly to the solver. If it spots an error, rather than giving up, the LLM tries to fix the broken part of the formulation.
When the researchers tested their framework on nine complex challenges, such as minimizing the distance warehouse robots must travel to complete tasks, it achieved an 85 percent success rate, whereas the best baseline only achieved a 39 percent success rate.
The versatile framework could be applied to a range of multistep planning tasks, such as scheduling airline crews or managing machine time in a factory.
‚ÄúOur research introduces a framework that essentially acts as a smart assistant for planning problems. It can figure out the best plan that meets all the needs you have, even if the rules are complicated or unusual,‚Äù says Yilun Hao, a graduate student in the MIT Laboratory for Information and Decision Systems (LIDS) and lead author of a paper on this research.
She is joined on the paper by Yang Zhang, a research scientist at the MIT-IBM Watson AI Lab; and senior author Chuchu Fan, an associate professor of aeronautics and astronautics and LIDS principal investigator. The research will be presented at the International Conference on Learning Representations.
Optimization 101
The Fan group develops algorithms that automatically solve what are known as combinatorial optimization problems. These vast problems have many interrelated decision variables, each with multiple options that rapidly add up to billions of potential choices.
Humans solve such problems by narrowing them down to a few options and then determining which one leads to the best overall plan. The researchers‚Äô algorithmic solvers apply the same principles to optimization problems that are far too complex for a human to crack.
But the solvers they develop tend to have steep learning curves and are typically only used by experts.
‚ÄúWe thought that LLMs could allow nonexperts to use these solving algorithms. In our lab, we take a domain expert‚Äôs problem and formalize it into a problem our solver can solve. Could we teach an LLM to do the same thing?‚Äù Fan says.
Using the framework the researchers developed, called LLM-Based Formalized Programming (LLMFP), a person provides a natural language description of the problem, background information on the task, and a query that describes their goal.
Then LLMFP prompts an LLM to reason about the problem and determine the decision variables and key constraints that will shape the optimal solution.
LLMFP asks the LLM to detail the requirements of each variable before encoding the information into a mathematical formulation of an optimization problem. It writes code that encodes the problem and calls the attached optimization solver, which arrives at an ideal solution.
‚ÄúIt is similar to how we teach undergrads about optimization problems at MIT. We don‚Äôt teach them just one domain. We teach them the methodology,‚Äù Fan adds.
As long as the inputs to the solver are correct, it will give the right answer. Any mistakes in the solution come from errors in the formulation process.
To ensure it has found a working plan, LLMFP analyzes the solution and modifies any incorrect steps in the problem formulation. Once the plan passes this self-assessment, the solution is described to the user in natural language.
Perfecting the plan
This self-assessment module also allows the LLM to add any implicit constraints it missed the first time around, Hao says.
For instance, if the framework is optimizing a supply chain to minimize costs for a coffeeshop, a human knows the coffeeshop can‚Äôt ship a negative amount of roasted beans, but an LLM might not realize that.
The self-assessment step would flag that error and prompt the model to fix it.
‚ÄúPlus, an LLM can adapt to the preferences of the user. If the model realizes a particular user does not like to change the time or budget of their travel plans, it can suggest changing things that fit the user‚Äôs needs,‚Äù Fan says.
In a series of tests, their framework achieved an average success rate between 83 and 87 percent across nine diverse planning problems using several LLMs. While some baseline models were better at certain problems, LLMFP achieved an overall success rate about twice as high as the baseline techniques.
Unlike these other approaches, LLMFP does not require domain-specific examples for training. It can find the optimal solution to a planning problem right out of the box.
In addition, the user can adapt LLMFP for different optimization solvers by adjusting the prompts fed to the LLM.
‚ÄúWith LLMs, we have an opportunity to create an interface that allows people to use tools from other domains to solve problems in ways they might not have been thinking about before,‚Äù Fan says.
In the future, the researchers want to enable LLMFP to take images as input to supplement the descriptions of a planning problem. This would help the framework solve tasks that are particularly hard to fully describe with natural language.
This work was funded, in part, by the Office of Naval Research and the MIT-IBM Watson AI Lab. </article> <!-- ‚úÖ Êàª„Çã„Éú„Çø„É≥ --> <div class="mt-10 text-center"> <a id="backLink" href="#" class="inline-block px-4 py-2 border border-sky-600 text-sky-600 rounded hover:bg-gray-100 transition">
‚Üê ‰∏ÄË¶ß„Å∏Êàª„Çã
</a> </div> </div> <!-- ‚úÖ base „ÇíÊ≠£„Åó„ÅèÂüã„ÇÅËæº„ÇÄ --> <script id="baseScript" data-base="/ai-news-curation-site"></script> <!-- ‚úÖ Êàª„Çã„É™„É≥„ÇØ„ÇíÊ≠£„Åó„ÅèÊßãÁØâ --> <script>
      const base = document.getElementById('baseScript')?.dataset.base || '';
      console.log("‚úÖ base:", base);

      const params = new URL(window.location.href).searchParams;
      const fromPage = params.get("fromPage") || "1";
      const fromSort = params.get("fromSort") || "date";

      const backLink = document.getElementById("backLink");
      if (backLink) {
        backLink.href = `${base}/page/${fromSort}/${fromPage}`;
        console.log("‚úÖ backLink.href:", backLink.href);
      } else {
        console.warn("‚ö†Ô∏è backLink not found");
      }
    </script> </body> </html>